// Generated by CoffeeScript 1.9.0
var Bus, actions, debug, errorHandler, thinky, utils;

thinky = require("thinky");

debug = require('debug')("mithink:bus");

actions = require('./actions');

utils = require('../utils');

errorHandler = require('./error-handler');

Bus = function(io) {
  Bus.io = io;
  return Bus;
};

Bus.__actions__ = {};

Bus.__tables__ = [];

Bus.NAMESPACE = "mithink";

require('./access-control')(Bus);

Bus.extend = function(model) {
  model.__mithink__ = {
    actions: {}
  };
  model.guard = Bus.guard.bind({
    model: model
  });

  /**
   * @class Server.Model 
   * @description The Server-side Model object
   * @property channel { Socket.IO.Channel } The socket.io channel for a given model
   * @example
   *   Thing = mithink.createModel 'Thing', schema, options
   */
  model.channel = Bus.io.of(utils.channelName(model._name));

  /**
   * add custom events to a channel so that they can have access control handlers
   * @class Server.Model 
   * @function Server.Model#registerActions
   * @param {Object} actions - set of actions and handlers to register, will over-write preexisting handlers
   * @example
   * Thing.registerActions {
   *   mapreduce: (data)->
   *     return false unless socket.authenticated
   *     Thing.map(m).reduce(r).exec().then (data)=>
   *       # send data back to client that asked for it on the channel the event was received on
   *       this.socket.emit "mapreduce", data
   * }
   */
  model.registerActions = Bus._actionable_.bind(model.__mithink__);
  model.registerActions(actions);
  model.channel.on("connection", Bus.wrap.bind({
    model: model
  }));
  return Bus;
};

Bus.wireUp = function(model) {
  if (!~Bus.__tables__.indexOf(model._name)) {
    Bus.__tables__.push(model._name);
    model.changes().then(function(feed) {
      return feed.each(function(err, doc) {
        if (err) {
          debug(err);
          throw err;
        }
        if (!doc.isSaved()) {
          debug("emitting destroy...");
          return model.channel.emit('destroy', doc);
        }
        debug("emitting upsert...");
        return model.channel.emit('upsert', doc);
      });
    });
  }
  return Bus;
};

Bus.wrap = function(socket) {
  var ctx;
  ctx = {
    socket: socket,
    model: this.model
  };
  return Bus.__protect__.call(utils.merge(ctx, {
    action: 'connection'
  }), function() {
    var action, handler, _ref, _results;
    Bus.__protect__.call(utils.merge(ctx, {
      action: 'load'
    }), this.model.__mithink__.actions.load)();
    _ref = this.model.__mithink__.actions;
    _results = [];
    for (action in _ref) {
      handler = _ref[action];
      _results.push((function(action, handler) {
        return socket.on(action, Bus.__protect__.call(utils.merge(ctx, {
          action: action
        }), handler));
      })(action, handler));
    }
    return _results;
  })();
};

Bus._actionable_ = function(opts) {
  var action, handler, _results;
  if (opts == null) {
    opts = {};
  }
  _results = [];
  for (action in opts) {
    handler = opts[action];
    _results.push(this.actions[action] = handler);
  }
  return _results;
};

module.exports = Bus;
